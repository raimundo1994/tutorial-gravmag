'''
This code presents a general approach for implementing the gravitational
potential and vertical component of the gravitational acceleration produced
by a rectangular prism by using the analytical formulas of
Nagy et al (2000, 2002). This prototype is inspired on
[Harmonica](https://www.fatiando.org/harmonica/latest/index.html)
(Uieda et al, 2020). It makes use of the modified arctangent function proposed
by Fukushima (2020, eq. 72) and of a modified logarithm function for dealing
with singularities at some computation points.
'''


import numpy as np
from numba import njit


#: The gravitational constant in m^3 kg^{-1} s^{-1}
GRAVITATIONAL_CONST = 0.00000000006673

#: The magnetic constant in u0/4pi x 10^9
MAGNETIC_CONST = 100
CM = 1e-7

#: Transforming constants
SI2MGAL = 1e5
SI2EOTVOS = 1e9
T2NT = 1e9


def grav(coordinates, prisms, density, field):
    """
    Gravitational potential, first and second derivatives
    produced by a right-rectangular prism in Cartesian coordinates.
    All values are referred to a topocentric Cartesian system with axes
    x, y and z pointing to north, east and down, respectively.

    Parameters
    ----------
    coordinates : 2d-array
        2d-array containing y (first line), x (second line), and z (third line) of
        the computation points. All coordinates should be in meters.
    prisms : 2d-array
        2d-array containing the coordinates of the prisms. Each line must contain
        the coordinates of a single prism in the following order:
        west (y1), east (y2), south (x1), north (x2), top (z1) and bottom (z2).
        All coordinates should be in meters.
    density : 1d-array
        1d-array containing the density of each prism in kg/m^3.
    field : str
        Gravitational field to be computed.
        The available fields are:

        - Gravitational potential: ``g_potential``
        - z-component of acceleration: ``g_z``
        - y-component of acceleration: ``g_y``
        - x-component of acceleration: ``g_x``
        - zz-component of acceleration: ``g_zz``
        - yz-component of acceleration: ``g_yz``
        - xz-component of acceleration: ``g_xz``
        - yy-component of acceleration: ``g_yy``
        - xy-component of acceleration: ``g_xy``
        - xx-component of acceleration: ``g_xx``

    Returns
    -------
    result : array
        Gravitational field generated by the prisms at the computation points.

    """

    # Available fields
    fields = {
        "g_potential": kernel_inverse_r,
        "g_x": kernel_dx,
        "g_y": kernel_dy,
        "g_z": kernel_dz,
        "g_xx": kernel_dxx,
        "g_xy": kernel_dxy,
        "g_xz": kernel_dxz,
        "g_yy": kernel_dyy,
        "g_yz": kernel_dyz,
        "g_zz": kernel_dzz
    }

    # Verify the field
    if field not in fields:
        raise ValueError("Gravitational field {} not recognized".format(field))

    # Verify the input parameters
    _check_prisms(prisms)
    _check_coordinates(coordinates)
    _check_density(density, prisms)

    # create the array to store the result
    result = np.zeros(coordinates[0].size, dtype="float64")

    # Compute gravitational field
    jit_grav(coordinates, prisms, density, fields[field], result)
    result *= GRAVITATIONAL_CONST
    # Convert from m/s^2 to mGal
    if field in ["g_x", "g_y", "g_z"]:
        result *= SI2MGAL
    # Convert from 1/s^2 to Eötvös
    if field in ["g_xx", "g_xy", "g_xz", "g_yy", "g_yz", "g_zz"]:
        result *= SI2EOTVOS
    return result


def mag(coordinates, prisms, magnetization, field):
    """
    Magnetic scalar potential and magnetic induction components
    produced by a right-rectangular prism in Cartesian coordinates.
    All values are referred to a topocentric Cartesian system with axes
    x, y and z pointing to north, east and down, respectively.

    Parameters
    ----------
    coordinates : 2d-array
        2d-array containing y (first line), x (second line), and z (third line) of
        the computation points. All coordinates should be in meters.
    prisms : 2d-array
        2d-array containing the coordinates of the prisms. Each line must contain
        the coordinates of a single prism in the following order:
        west (y1), east (y2), south (x1), north (x2), top (z1) and bottom (z2).
        All coordinates should be in meters.
    magnetization : 2d-array
        2d-array containing the total-magnetization components of the prisms.
        Each line must contain the intensity (in A/m), inclination and
        declination (in degrees) of the total magnetization of a single prism.
    field : str
        Magnetic field to be computed.
        The available fields are:

        - Magnetic scalar potential: ``b_potential``
        - z-component of induction: ``b_z``
        - y-component of induction: ``b_y``
        - x-component of induction: ``b_x``

    Returns
    -------
    result : array
        Magnetic field generated by the prisms at the computation points.

    """

    # Available fields
    fields = {
        "b_potential": {"x": kernel_dx,
                        "y": kernel_dy,
                        "z": kernel_dz},
        "b_z": {"x": kernel_dxz,
                "y": kernel_dyz,
                "z": kernel_dzz},
        "b_y": {"x": kernel_dxy,
                "y": kernel_dyy,
                "z": kernel_dyz},
        "b_x": {"x": kernel_dxx,
                "y": kernel_dxy,
                "z": kernel_dxz},
    }

    # Verify the field
    if field not in fields:
        raise ValueError("Magnetic field {} not recognized".format(field))

    # Verify the input parameters
    _check_prisms(prisms)
    _check_coordinates(coordinates)
    _check_magnetization(magnetization, prisms)

    # create the array to store the result
    result = np.zeros(coordinates[0].size, dtype="float64")

    # Compute the Cartesian components of total-magnetization
    my, mx, mz = magnetization_components(magnetization)

    # Compute magnetic field
    fieldx = fields[field]["x"]
    fieldy = fields[field]["y"]
    fieldz = fields[field]["z"]
    jit_mag(coordinates, prisms, my, mx, mz, fieldx, fieldy, fieldz, result)
    #result *= CM*T2NT
    result *= MAGNETIC_CONST
    if field == "b_potential":
        result *= -1
    return result


@njit
def jit_grav(coordinates, prisms, density, field, out):
    """
    Compute the gravitational field at the points in 'coordinates'
    """
    # Iterate over computation points
    for l in range(coordinates[0].size):
        # Iterate over prisms
        for p in range(prisms.shape[0]):
            # Change coordinates
            Y1 = prisms[p,0] - coordinates[0,l]
            Y2 = prisms[p,1] - coordinates[0,l]
            X1 = prisms[p,2] - coordinates[1,l]
            X2 = prisms[p,3] - coordinates[1,l]
            Z1 = prisms[p,4] - coordinates[2,l]
            Z2 = prisms[p,5] - coordinates[2,l]
            # Compute the field
            out[l] += density[p] * (
                  field(Y2, X2, Z2)
                - field(Y2, X2, Z1)
                - field(Y2, X1, Z2)
                + field(Y2, X1, Z1)
                - field(Y1, X2, Z2)
                + field(Y1, X2, Z1)
                + field(Y1, X1, Z2)
                - field(Y1, X1, Z1)
            )


@njit
def jit_mag(coordinates, prisms, my, mx, mz, fieldx, fieldy, fieldz, out):
    """
    Compute the magnetic field at the points in 'coordinates'
    """
    # Iterate over computation points
    for l in range(coordinates[0].size):
        # Iterate over prisms
        for p in range(prisms.shape[0]):
            # Change coordinates
            Y1 = prisms[p,0] - coordinates[0,l]
            Y2 = prisms[p,1] - coordinates[0,l]
            X1 = prisms[p,2] - coordinates[1,l]
            X2 = prisms[p,3] - coordinates[1,l]
            Z1 = prisms[p,4] - coordinates[2,l]
            Z2 = prisms[p,5] - coordinates[2,l]
            # Compute the field component y
            out[l] += my[p] * (
                  fieldy(Y2, X2, Z2)
                - fieldy(Y2, X2, Z1)
                - fieldy(Y2, X1, Z2)
                + fieldy(Y2, X1, Z1)
                - fieldy(Y1, X2, Z2)
                + fieldy(Y1, X2, Z1)
                + fieldy(Y1, X1, Z2)
                - fieldy(Y1, X1, Z1)
            )
            # Compute the field component x
            out[l] += mx[p] * (
                  fieldx(Y2, X2, Z2)
                - fieldx(Y2, X2, Z1)
                - fieldx(Y2, X1, Z2)
                + fieldx(Y2, X1, Z1)
                - fieldx(Y1, X2, Z2)
                + fieldx(Y1, X2, Z1)
                + fieldx(Y1, X1, Z2)
                - fieldx(Y1, X1, Z1)
            )
            # Compute the field component z
            out[l] += mz[p] * (
                  fieldz(Y2, X2, Z2)
                - fieldz(Y2, X2, Z1)
                - fieldz(Y2, X1, Z2)
                + fieldz(Y2, X1, Z1)
                - fieldz(Y1, X2, Z2)
                + fieldz(Y1, X2, Z1)
                + fieldz(Y1, X1, Z2)
                - fieldz(Y1, X1, Z1)
            )

# kernels

@njit
def kernel_inverse_r(Y, X, Z):
    """
    Function for computing the inverse distance kernel
    """
    R = np.sqrt(X**2 + Y**2 + Z**2)
    result = (
        Y * X * safe_log(Z + R)
        + X * Z * safe_log(Y + R)
        + Y * Z * safe_log(X + R)
        - 0.5 * Y ** 2 * safe_atan2(Z * X, Y * R)
        - 0.5 * X ** 2 * safe_atan2(Z * Y, X * R)
        - 0.5 * Z ** 2 * safe_atan2(Y * X, Z * R)
    )
    return result


@njit
def kernel_dz(Y, X, Z):
    """
    Function for computing the z-derivative of inverse distance kernel
    """
    R = np.sqrt(X**2 + Y**2 + Z**2)
    result = -(
        Y * safe_log(X + R)
        + X * safe_log(Y + R)
        - Z * safe_atan2(Y * X, Z * R)
    )
    return result


@njit
def kernel_dy(Y, X, Z):
    """
    Function for computing the y-derivative of inverse distance kernel
    """
    R = np.sqrt(X**2 + Y**2 + Z**2)
    result = -(
        X * safe_log(Z + R)
        + Z * safe_log(X + R)
        - Y * safe_atan2(X * Z, Y * R)
    )
    return result


@njit
def kernel_dx(Y, X, Z):
    """
    Function for computing the x-derivative of inverse distance kernel
    """
    R = np.sqrt(X**2 + Y**2 + Z**2)
    result = -(
        Y * safe_log(Z + R)
        + Z * safe_log(Y + R)
        - X * safe_atan2(Y * Z, X * R)
    )
    return result


@njit
def kernel_dzz(Y, X, Z):
    """
    Function for computing the zz-derivative of inverse distance kernel
    """
    R = np.sqrt(X**2 + Y**2 + Z**2)
    result = - safe_atan2(Y * X, Z * R)
    return result


@njit
def kernel_dyz(Y, X, Z):
    """
    Function for computing the yz-derivative of inverse distance kernel
    """
    R = np.sqrt(X**2 + Y**2 + Z**2)
    result = safe_log(X + R)
    return result


@njit
def kernel_dxz(Y, X, Z):
    """
    Function for computing the xz-derivative of inverse distance kernel
    """
    R = np.sqrt(X**2 + Y**2 + Z**2)
    result = safe_log(Y + R)
    return result


@njit
def kernel_dyy(Y, X, Z):
    """
    Function for computing the yy-derivative of inverse distance kernel
    """
    R = np.sqrt(X**2 + Y**2 + Z**2)
    result = - safe_atan2(X * Z, Y * R)
    return result


@njit
def kernel_dxy(Y, X, Z):
    """
    Function for computing the xy-derivative of inverse distance kernel
    """
    R = np.sqrt(X**2 + Y**2 + Z**2)
    result = safe_log(Z + R)
    return result


@njit
def kernel_dxx(Y, X, Z):
    """
    Function for computing the xx-derivative of inverse distance kernel
    """
    R = np.sqrt(X**2 + Y**2 + Z**2)
    result = - safe_atan2(Y * Z, X * R)
    return result


# auxiliary functions

def _check_prisms(prisms):
    """
    Check if prisms are well defined

    Parameters
    ----------
    prisms : 2d-array
        Array containing the boundaries of the prisms in the following order:
        ``w``, ``e``, ``s``, ``n``, ``top``, ``bottom``.
        The array must have the following shape: (``n_prisms``, 6), where
        ``n_prisms`` is the total number of prisms.
        This array of prisms must have valid boundaries.
        Run ``_check_prisms`` before.
    """
    prisms = np.asarray(prisms)
    if prisms.ndim != 2:
        raise ValueError(
            "prisms ndim ({}) ".format(prisms.ndim)
            + "not equal to 2"
        )
    if prisms.shape[1] != 6:
        raise ValueError(
            "Number of columns in prisms ({}) ".format(prisms.shape[1])
            + "not equal to 6"
        )
    west, east, south, north, top, bottom = tuple(prisms[:, i] for i in range(6))
    err_msg = "Invalid prism or prisms. "
    bad_we = west > east
    bad_sn = south > north
    bad_bt = top > bottom
    if bad_we.any():
        err_msg += "The west boundary can't be greater than the east one.\n"
        for prism in prisms[bad_we]:
            err_msg += "\tInvalid prism: {}\n".format(prism)
        raise ValueError(err_msg)
    if bad_sn.any():
        err_msg += "The south boundary can't be greater than the north one.\n"
        for prism in prisms[bad_sn]:
            err_msg += "\tInvalid prism: {}\n".format(prism)
        raise ValueError(err_msg)
    if bad_bt.any():
        err_msg += "The top boundary can't be greater than the bottom one.\n"
        for prism in prisms[bad_bt]:
            err_msg += "\tInvalid prism: {}\n".format(prism)
        raise ValueError(err_msg)


def _check_coordinates(coordinates):
    """
    Check if coordinates are well defined

    Parameters
    ----------
    coordinates : 2d-array
        2d-array containing y (first line), x (second line), and z (third line) of
        the computation points. All coordinates should be in meters.
        Run ``_check_coordinates`` before.
    """
    coordinates = np.asarray(coordinates)
    if coordinates.ndim != 2:
        raise ValueError(
            "coordinates ndim ({}) ".format(coordinates.ndim)
            + "not equal to 2"
        )
    if coordinates.shape[0] != 3:
        raise ValueError(
            "Number of lines in coordinates ({}) ".format(coordinates.shape[0])
            + "not equal to 3"
        )


def _check_density(density, prisms):
    """
    Check if densities are well defined. Run ``_check_prisms`` before.

    Parameters
    ----------
    density : 1d-array
        1d-array containing the density of each prism in kg/m^3.
    prisms : 2d-array
        2d-array containing the coordinates of the prisms. Each line must contain
        the coordinates of a single prism in the following order:
        west (y1), east (y2), south (x1), north (x2), top (z1) and bottom (z2).
        All coordinates should be in meters.
    """
    density = np.asarray(density)
    if density.ndim != 1:
        raise ValueError(
            "density ndim ({}) ".format(density.ndim)
            + "not equal to 1"
        )
    if density.size != prisms.shape[0]:
        raise ValueError(
            "Number of elements in density ({}) ".format(density.size)
            + "mismatch the number of prisms ({})".format(prisms.shape[0])
        )


def _check_magnetization(magnetization, prisms):
    """
    Check if magnetizations are well defined. Run ``_check_prisms`` before.

    Parameters
    ----------
    magnetization : 1d-array
        2d-array containing the total-magnetization components of the prisms.
        Each line must contain the y, x and z components of the total
        magnetization of a single prism.
        All values should be in A/m.
    prisms : 2d-array
        2d-array containing the coordinates of the prisms. Each line must contain
        the coordinates of a single prism in the following order:
        west (y1), east (y2), south (x1), north (x2), top (z1) and bottom (z2).
        All coordinates should be in meters.
    """
    magnetization = np.asarray(magnetization)
    if magnetization.ndim != 2:
        raise ValueError(
            "magnetization ndim ({}) ".format(magnetization.ndim)
            + "not equal to 2"
        )
    if magnetization.shape[1] != 3:
        raise ValueError(
            "magnetization ndim ({}) ".format(magnetization.shape[1])
            + "not equal to 3"
        )
    if magnetization.shape[0] != prisms.shape[0]:
        raise ValueError(
            "Number of elements in magnetization ({}) ".format(magnetization.size)
            + "mismatch the number of prisms ({})".format(prisms.shape[0])
        )


def magnetization_components(magnetization):
    """
    Given the total-magnetization intensity, inclination and declination,
    compute the Cartesian components my, mx and mz.
    Run ``_check_magnetization`` before.
    """
    # transform inclination and declination from degrees to radians
    inc = np.deg2rad(magnetization[:,1])
    dec = np.deg2rad(magnetization[:,2])
    # compute the sines and cosines
    cos_inc = np.cos(inc)
    sin_inc = np.sin(inc)
    cos_dec = np.cos(dec)
    sin_dec = np.sin(dec)
    # compute the Cartesian components
    my = magnetization[:,0]*cos_inc*sin_dec
    mx = magnetization[:,0]*cos_inc*cos_dec
    mz = magnetization[:,0]*sin_inc
    return my, mx, mz


@njit
def safe_atan2(y, x):
    """
    Principal value of the arctangent expressed as a two variable function

    This modification has to be made to the arctangent function so the
    gravitational field of the prism satisfies the Poisson's equation.
    Therefore, it guarantees that the fields satisfies the symmetry properties
    of the prism. This modified function has been defined according to
    Fukushima (2020, eq. 72).
    """
    if x != 0:
        result = np.arctan(y / x)
    else:
        if y > 0:
            result = np.pi / 2
        elif y < 0:
            result = -np.pi / 2
        else:
            result = 0
    return result


@njit
def safe_log(x):
    """
    Modified log to return 0 for log(0).
    The limits in the formula terms tend to 0.
    """
    if np.abs(x) < 1e-10:
        result = 0
    else:
        result = np.log(x)
    return result
